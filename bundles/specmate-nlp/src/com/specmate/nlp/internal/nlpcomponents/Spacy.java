package com.specmate.nlp.internal.nlpcomponents;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.ws.rs.core.Response.Status;

import org.apache.commons.lang3.Range;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.fit.component.JCasAnnotator_ImplBase;
import org.apache.uima.fit.descriptor.ConfigurationParameter;
import org.apache.uima.jcas.JCas;
import org.json.JSONArray;
import org.json.JSONObject;

import com.specmate.common.exception.SpecmateInternalException;
import com.specmate.model.administration.ErrorCode;
import com.specmate.rest.RestClient;
import com.specmate.rest.RestResult;

import de.tudarmstadt.ukp.dkpro.core.api.lexmorph.type.pos.POS;
import de.tudarmstadt.ukp.dkpro.core.api.segmentation.type.Sentence;
import de.tudarmstadt.ukp.dkpro.core.api.segmentation.type.Token;
import de.tudarmstadt.ukp.dkpro.core.api.syntax.type.dependency.Dependency;
import de.tudarmstadt.ukp.dkpro.core.api.syntax.type.dependency.DependencyFlavor;
import de.tudarmstadt.ukp.dkpro.core.api.syntax.type.dependency.ROOT;

public class Spacy extends JCasAnnotator_ImplBase {

	// Variables for REST Call (Spacy API)
	public static final String PARAM_SPACY_URL = "spacy_url";
	@ConfigurationParameter(name = PARAM_SPACY_URL, mandatory = false, defaultValue = "http://127.0.0.1:80")
	protected String SPACY_API_BASE_URL = "http://127.0.0.1:80";

	public static final java.lang.String PARAM_MODEL = "model";
	@ConfigurationParameter(name = PARAM_MODEL, mandatory = false, description = "Use this spacy model.")
	protected String spacyModel;

	private static final int TIMEOUT = 5000;

	@Override
	public void process(JCas jcas) throws AnalysisEngineProcessException {
		String text = jcas.getDocumentText();

		// Call Spacy API
		JSONObject result = null;

		try {
			result = accessSpacyAPI(text);
		} catch (SpecmateInternalException e) {
			throw new AnalysisEngineProcessException(e);
		}

		SpacyModel model = buildSpacyModel(result);

		annotateSentences(model, jcas);
		annotateTokens(model, jcas);
		annotateDependencies(model, jcas);
	}

	private JSONObject accessSpacyAPI(String requirement) throws SpecmateInternalException {

		RestClient restClient = new RestClient(SPACY_API_BASE_URL, TIMEOUT, null);
		try (restClient) {
			// Set model parameters
			JSONObject request = new JSONObject();
			request.put("text", requirement);
			request.put("model", spacyModel);
			request.put("collapse_punctuation", 0);
			request.put("collapse_phrases", 0);

			RestResult<JSONObject> result = restClient.post("/dep", request);
			if (result.getResponse().getStatus() == Status.OK.getStatusCode()) {
				result.getResponse().close();
				return result.getPayload();
			} else {
				result.getResponse().close();
				throw new SpecmateInternalException(ErrorCode.NLP,
						"Could not access Spacy API. Dependencies could not be loaded.");
			}
		}
	}

	private SpacyModel buildSpacyModel(JSONObject result) {
		JSONArray allWords = result.getJSONArray("words");

		// Search for all dependencies in which the current token is included.
		// allArcs = all dependencies that have been generated by Spacy.
		JSONArray allArcs = result.getJSONArray("arcs");

		SpacyModel model = new SpacyModel(allWords, allArcs);
		return model;
	}

	private void annotateSentences(SpacyModel model, JCas jcas) {
		String text = jcas.getDocumentText();
		int searchIndex = 0;

		List<Range<Integer>> ranges = new ArrayList<Range<Integer>>();
		for (Node root : model.getRoots()) {
			List<Node> nodes = model.getCovered(root);
			int begin = -1;
			int end = -1;
			for (Node n : nodes) {
				int nodeIndex = text.indexOf(n.text, searchIndex);
				if (begin == -1) {
					begin = nodeIndex;
				}
				searchIndex = nodeIndex;
				end = nodeIndex + n.text.length();
			}
			Range<Integer> r = Range.between(begin, end);
			ranges.add(r);
		}
		mergeRanges(ranges);
		for (Range<Integer> r : ranges) {
			Sentence sentence = new Sentence(jcas, r.getMinimum(), r.getMaximum());
			sentence.addToIndexes();
		}
	}

	private void mergeRanges(List<Range<Integer>> ranges) {
		boolean merged = true;
		while (merged) {
			merged = false;
			outer: for (int i = 0; i < ranges.size(); i++) {
				for (int j = i + 1; j < ranges.size(); j++) {
					Range<Integer> r1 = ranges.get(i);
					Range<Integer> r2 = ranges.get(j);
					if (r1.isOverlappedBy(r2)) {
						ranges.remove(i);
						ranges.remove(j - 1); // i has already been removed and is before j
						ranges.add(Range.between(Math.min(r1.getMinimum(), r2.getMinimum()),
								Math.max(r1.getMaximum(), r2.getMaximum())));
						merged = true;
						break outer;
					}
				}
			}
		}
	}

	private void annotateTokens(SpacyModel model, JCas jcas) {
		String allText = jcas.getDocumentText();
		int currentIndex = 0;
		List<Node> allWords = model.getNodes();
		for (Node word : allWords) {
			int foundIndex = allText.indexOf(word.text, currentIndex);
			Token token = new Token(jcas, foundIndex, foundIndex + word.text.length());
			POS posAnno = new POS(jcas, token.getBegin(), token.getEnd());
			// To save memory, we typically intern() tag strings
			posAnno.setPosValue(word.tag != null ? word.tag.intern() : null);
			posAnno.addToIndexes();
			token.setPos(posAnno);
			token.addToIndexes();
			word.token = token;
			currentIndex = currentIndex + word.text.length();
		}
	}

	private void annotateDependencies(SpacyModel model, JCas jcas) {

		for (Pair<Node, Node> currentArc : model.getAllConnections()) {

			Node parent = currentArc.getLeft();
			Node child = currentArc.getRight();

			// Check whether the token is the "start" of dependency
			// if yes, we create a corresponding Dependency and add it to the JCas
			Dependency dep = new Dependency(jcas);
			dep.setDependencyType(child.label);
			dep.setFlavor(DependencyFlavor.BASIC);
			dep.setDependent(child.token);
			dep.setGovernor(parent.token);
			dep.setBegin(dep.getDependent().getBegin());
			dep.setEnd(dep.getDependent().getEnd());
			dep.addToIndexes();
		}

		for (Node root : model.getRoots()) {
			Dependency dep = new ROOT(jcas);
			dep.setDependencyType("ROOT");
			dep.setFlavor(DependencyFlavor.BASIC);
			dep.setGovernor(root.token);
			dep.setDependent(root.token);
			dep.setBegin(dep.getDependent().getBegin());
			dep.setEnd(dep.getDependent().getEnd());
			dep.addToIndexes();
		}
	}

	private class SpacyModel {
		public Map<Integer, Node> nodeMap = new HashMap<>();

		public SpacyModel(JSONArray allWords, JSONArray allDeps) {
			for (int i = 0; i < allWords.length(); i++) {
				JSONObject word = allWords.getJSONObject(i);
				createNode(i, word.getString("text"), word.getString("tag"));
			}
			for (int i = 0; i < allDeps.length(); i++) {
				JSONObject currentArc = allDeps.getJSONObject(i);

				int start = currentArc.getInt("start");
				int end = currentArc.getInt("end");
				String label = currentArc.getString("label");
				String dir = currentArc.getString("dir");

				// Is the current token a dependent or governor?
				// The token is a dependent if the arrow of the dependency points to the token
				// and vice versa.
				if (dir.equals("left")) {
					connect(end, start, label);
				} else if (dir.equals("right")) {
					connect(start, end, label);
				}
			}
		}

		public List<Node> getNodes() {
			List<Node> nodes = new ArrayList<>(nodeMap.values());
			Collections.sort(nodes);
			return nodes;
		}

		public Node createNode(Integer id, String text, String tag) {
			Node node = new Node(id, text, tag);
			nodeMap.put(id, node);
			return node;
		}

		public void connect(Integer parent, Integer child, String label) {
			Node childNode = nodeMap.get(child);
			nodeMap.get(parent).addChild(childNode);
			childNode.label = label;
		}

		public Set<Node> getRoots() {
			return nodeMap.values().stream().filter(n -> n.parent == null).sorted().collect(Collectors.toSet());
		}

		public List<Node> getCovered(Node root) {
			List<Node> coveredNodes = new ArrayList<>();
			LinkedList<Node> workList = new LinkedList<>();
			workList.add(root);
			while (!workList.isEmpty()) {
				Node current = workList.pop();
				coveredNodes.add(current);
				workList.addAll(current.children);
			}
			Collections.sort(coveredNodes);
			return coveredNodes;
		}

		public List<Pair<Node, Node>> getAllConnections() {
			List<Pair<Node, Node>> connections = new ArrayList<>();
			LinkedList<Node> workList = new LinkedList<>(getRoots());
			while (!workList.isEmpty()) {
				Node current = workList.pop();
				current.children.stream().map(c -> Pair.of(current, c)).forEach(connections::add);
				workList.addAll(current.children);
			}
			Collections.sort(connections);
			return connections;
		}
	}

	private class Node implements Comparable<Node> {

		public Node(Integer id, String text, String tag) {
			super();
			this.id = id;
			this.text = text;
			this.tag = tag;
		}

		public Integer id;
		public String text;
		public String tag;
		public String label;
		public Token token;
		public Node parent;
		public List<Node> children = new ArrayList<>();

		public void addChild(Node child) {
			children.add(child);
			child.parent = this;
		}

		@Override
		public int compareTo(Node other) {
			return id.compareTo(other.id);
		}
	}
}
